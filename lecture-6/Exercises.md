# Data Structures & Algorithms — Practice Worksheet

### Arrays

1. Implement a function to reverse an array in place without using built-in reverse.
2. Given an array of numbers, return a new array with only unique elements.
3. Rotate an array `k` steps to the right without using extra space.
4. Find the maximum subarray sum (Kadane’s algorithm).
5. Merge two sorted arrays into one sorted array.

### Strings

1. Check if two strings are anagrams.
2. Find the first non-repeating character in a string.
3. Implement a function to check if a string is a palindrome, ignoring non-alphanumeric characters.
4. Compress a string (e.g., `aaabbc → a3b2c1`).
5. Implement substring search without using built-in functions.

### Linked Lists

1. Implement a singly linked list with insert, delete, and search operations.
2. Reverse a linked list iteratively and recursively.
3. Detect if a linked list has a cycle.
4. Merge two sorted linked lists into one sorted list.
5. Find the middle element of a linked list.

### Stacks and Queues

1. Implement a stack using arrays.
2. Implement a queue using two stacks.
3. Evaluate a postfix expression using a stack.
4. Check if parentheses in a string are balanced.
5. Implement a circular queue.

### Hash Maps / Sets

1. Implement a hash map from scratch with `set`, `get`, and `delete`.
2. Given an array, find if there are two numbers that add up to a target (two-sum problem).
3. Find the first repeated character in a string.
4. Group words that are anagrams together.
5. Find the longest substring without repeating characters.

### Trees

1. Implement a binary tree with insert and search.
2. Perform inorder, preorder, and postorder traversal recursively.
3. Perform level-order traversal using a queue.
4. Find the maximum depth of a binary tree.
5. Check if a binary tree is a valid binary search tree.

### Graphs

1. Represent a graph using adjacency list and adjacency matrix.
2. Implement depth-first search (DFS).
3. Implement breadth-first search (BFS).
4. Detect if a graph has a cycle.
5. Find the shortest path in an unweighted graph using BFS.

### Complexity & Patterns

1. Analyze the time and space complexity of your `two-sum` implementation.
2. Explain the difference between O(1), O(log n), O(n), O(n log n), and O(n^2) with examples.
3. Apply the sliding window technique to find the maximum sum of a subarray of size `k`.
4. Use the two-pointer technique to check if an array has a pair with a given sum.
5. Implement binary search and analyze its complexity.